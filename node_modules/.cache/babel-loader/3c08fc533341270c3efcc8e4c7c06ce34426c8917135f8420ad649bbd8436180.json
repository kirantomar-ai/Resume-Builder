{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/helpers/esm/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useEffect, useRef } from 'react';\nimport raf from \"rc-util/es/raf\";\nimport useState from \"rc-util/es/hooks/useState\";\n/**\n * Popup should follow the steps for each component work correctly:\n * measure - check for the current stretch size\n * align - let component align the position\n * aligned - re-align again in case additional className changed the size\n * afterAlign - choice next step is trigger motion or finished\n * beforeMotion - should reset motion to invisible so that CSSMotion can do normal motion\n * motion - play the motion\n * stable - everything is done\n */\n\nvar StatusQueue = ['measure', 'alignPre', 'align', null, 'motion'];\nexport default (function (visible, doMeasure) {\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    status = _useState2[0],\n    setInternalStatus = _useState2[1];\n  var rafRef = useRef();\n  function setStatus(nextStatus) {\n    setInternalStatus(nextStatus, true);\n  }\n  function cancelRaf() {\n    raf.cancel(rafRef.current);\n  }\n  function goNextStatus(callback) {\n    cancelRaf();\n    rafRef.current = raf(function () {\n      // Only align should be manually trigger\n      setStatus(function (prev) {\n        switch (status) {\n          case 'align':\n            return 'motion';\n          case 'motion':\n            return 'stable';\n          default:\n        }\n        return prev;\n      });\n      callback === null || callback === void 0 ? void 0 : callback();\n    });\n  } // Init status\n\n  useEffect(function () {\n    setStatus('measure');\n  }, [visible]); // Go next status\n\n  useEffect(function () {\n    switch (status) {\n      case 'measure':\n        doMeasure();\n        break;\n      default:\n    }\n    if (status) {\n      rafRef.current = raf( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var index, nextStatus;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                index = StatusQueue.indexOf(status);\n                nextStatus = StatusQueue[index + 1];\n                if (nextStatus && index !== -1) {\n                  setStatus(nextStatus);\n                }\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      })));\n    }\n  }, [status]);\n  useEffect(function () {\n    return function () {\n      cancelRaf();\n    };\n  }, []);\n  return [status, goNextStatus];\n});","map":{"version":3,"names":["_regeneratorRuntime","_asyncToGenerator","_slicedToArray","useEffect","useRef","raf","useState","StatusQueue","visible","doMeasure","_useState","_useState2","status","setInternalStatus","rafRef","setStatus","nextStatus","cancelRaf","cancel","current","goNextStatus","callback","prev","mark","_callee","index","wrap","_callee$","_context","next","indexOf","stop"],"sources":["C:/Users/91876/programming/ResumeBuilderFrontendProject/node_modules/rc-trigger/es/Popup/useVisibleStatus.js"],"sourcesContent":["import _regeneratorRuntime from \"@babel/runtime/helpers/esm/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useEffect, useRef } from 'react';\nimport raf from \"rc-util/es/raf\";\nimport useState from \"rc-util/es/hooks/useState\";\n/**\n * Popup should follow the steps for each component work correctly:\n * measure - check for the current stretch size\n * align - let component align the position\n * aligned - re-align again in case additional className changed the size\n * afterAlign - choice next step is trigger motion or finished\n * beforeMotion - should reset motion to invisible so that CSSMotion can do normal motion\n * motion - play the motion\n * stable - everything is done\n */\n\nvar StatusQueue = ['measure', 'alignPre', 'align', null, 'motion'];\nexport default (function (visible, doMeasure) {\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      status = _useState2[0],\n      setInternalStatus = _useState2[1];\n\n  var rafRef = useRef();\n\n  function setStatus(nextStatus) {\n    setInternalStatus(nextStatus, true);\n  }\n\n  function cancelRaf() {\n    raf.cancel(rafRef.current);\n  }\n\n  function goNextStatus(callback) {\n    cancelRaf();\n    rafRef.current = raf(function () {\n      // Only align should be manually trigger\n      setStatus(function (prev) {\n        switch (status) {\n          case 'align':\n            return 'motion';\n\n          case 'motion':\n            return 'stable';\n\n          default:\n        }\n\n        return prev;\n      });\n      callback === null || callback === void 0 ? void 0 : callback();\n    });\n  } // Init status\n\n\n  useEffect(function () {\n    setStatus('measure');\n  }, [visible]); // Go next status\n\n  useEffect(function () {\n    switch (status) {\n      case 'measure':\n        doMeasure();\n        break;\n\n      default:\n    }\n\n    if (status) {\n      rafRef.current = raf( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var index, nextStatus;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                index = StatusQueue.indexOf(status);\n                nextStatus = StatusQueue[index + 1];\n\n                if (nextStatus && index !== -1) {\n                  setStatus(nextStatus);\n                }\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      })));\n    }\n  }, [status]);\n  useEffect(function () {\n    return function () {\n      cancelRaf();\n    };\n  }, []);\n  return [status, goNextStatus];\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}